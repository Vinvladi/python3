# Базовый синтаксис
### Присваивание и ссылочная модель данных в Python

```python
x_1 = 2 + \
    3
# или вариант
x_2 = (2 +
     3)
```
Присваивание в python это связывание! Логика присваивания, состоит в том, что у нас появляется имя, которое отвечает за 
объект, но объект появляется раньше! Тип резервируется за объектом, а не именем.

```python
x = 2 ** 4000 # python скушает и это и выдаст вычисление без ошибки
```

Для 32-битные и 64-битные системы работают с числами: либо с 32 или 64

Подчеркивания игнорируются поэтому можно писать вот так для удобства:
```python
x = 123_456_789 # Для удобства в одной из версии python это было введено
```

У python каждый объект имеет свой идентификатор. Он длинный и мы его не знаем (Все объекты хранятся в куче)

После операции 2 + 3 у нас имя x начинает ссылаться на объект 5 (x ---> 5) 

Объем памяти в конечном счете конечен (есть разумный лимит). Утечка памяти (memory leak) [И еще разделение ресурсов]

После того как ссылка появилась, ссылки на 2 и 3 съедает garbage collector (таким образом, это называется сборка 
мусора)

x = 2
y = 5
x = y
y = x

Через 3 переменную:
```python
x = 2
y = 5
tmp = x
x = y
y = tmp
del tmp
```
Через 4 переменные
```python
x = 2
y = 5
tmp_1 = y  # Вводим 3-ую переменную
tmp_2 = x  # Вводим 4-ую переменную
x = tmp_1
y = tmp_2
'''
print(x,y) < ----- 5 , 2 (в итоге мы поменяли значения x ---> y , y ---> x)
'''
```
То же самое, только через множественное присваивание:
```python
x = 2
y = 5
tmp_1,tmp_2 = y,x
x,y = tmp_1, tmp_2
```
Имена не тратят много памяти

Через tuple (A)
```python
x = 2
y = 5
A = y,x  # Можно также: A = (y, x) тоже кортежное присваивание 
x,y = A  #(x,y) = A; Разворачивание кортежа (кортеж имен) [Unpucking]
type (A)
'''
type(A) = <class tuple>
'''
```
Исходя из этого всего, мы можем упростить:
```python
x = 2
y = 5
x,y = y,x  # по сути называется swap (внутри этого создаются еще переменные)
```

Для многих переменных:
```python
a = 1
b = 2
c = 3
a,b,c = b,c,a + b
```
```
Распаковка может быть применима, к любым итерируемым объектам.
```

### СТРОКИ
Запись: s = 'ABC', s = "ABC", s = r'ABC', s = f"ABC", s = """ABC""" <--- Литерал многострочной строки

Но если мы захотим спросить у python, а как ты видишь вот это:
```python
s = """ABC
DEF
GHI"""
print(repr(s)) 
'''
Выведет по итогу: "ABC\nDEF\nGHI"
'''
```

Но если:
```
path = C:\temp\input.txt в windows нормально не прокатит, так как будет понимать, что есть как будто экранирование 
path = r"C:\temp\input.txt"  # поэтому мы должны на windows писать так
```

```python
s = "ABC"
x,y,z = s
print(x, y, z)
'''
x = 'A', y = 'B', z = 'C'
'''
```
Но если мы будем распаковывать и там будет больше 3 элементов для распаковки: 
```python
s = "ABCDEF"
x,y,z = s
print(x, y, z)
'''
То у нас будет ошибка
'''
```
```
Чтобы избавиться от ошибки мы добавим *rest, тогда будет программа будет иметь вид:
```
```python
s = "ABCDEF"
x,y,z, *rest = s
print(rest)
print(type(rest))
'''
# ['D', 'E', 'F']
class <list>
'''
```

### Итерируемые объекты и бег по ним, с помощью цикла for
```python
A = ['D', 'E', 'F']  # Итерируемый объект типа последовательность.
for x in A:
    print(x)
```

```python
for x in 1,5,2,4,3:
    print(x**2)
```
```python
for x in 1,5,2,4,3:
    for x in 1,1,1:
        print(x)
'''
Выведет 15-ть 1 
1
1
1
...
1
'''
```
```
Не делайте так, а лучше другую переменную
```
```python
for x in 1,5,2,4,3:
    for y in 1,1,1:
        print(x)
```

### Последовательности и list:
```python
A = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
type(A)

for x in A:
    print(x)
'''
2
4
6
'''
```

```python
A = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
B = A
A[0] = 1000
'''
A = [1000, 4, 6, 8, 10, 12, 14, 16, 18, 20]
Причем и B изменился B = [1000, 4, 6, 8, 10, 12, 14, 16, 18, 20]
'''
A is B # True
C = A.copy()
A is C # False (показывает, что это разные объекты)
A == C # True
A[1] = 2000 # теперь у нас все это поменялось и будет:
print(A) # [1000, 2000, 6, 8, 10, 12, 14, 16, 18, 20]
print(B) # [1000, 2000, 6, 8, 10, 12, 14, 16, 18, 20]
print(C) # [1000, 4, 6, 8, 10, 12, 14, 16, 18, 20]
id(A)
id(B)
id(C)
A is B # True
id(A) == id(B) # True (Если объекты огромные, то они будут считаться долго)
x = 123
y = None
type(y) # NoneType
z = (2 + 2 == 4) # True
z = (2 + 2 == 5) # False
type(z) # bool
print(y) # None
print(123 == None)
print([123, 342] == None)
x is None # False
y is None # True
A[-1] = 999
print(A) # [1000, 2000, 6, 8, 10, 12, 14,16,18, 999]
len(A) # 10 <----- кол-во элементов, то же самое что:
A[len(A)-1] = 999
A = [1,2,3,4,5] # [1,2,3,4,5]
B = list(range(3, 0, -1)) # B = [3,2,1]
C = A + B  # [1, 2, 3, 4, 5, 3, 2, 1]
dir(A) # список всех команд
```
Методы __int__ - magick методы

Чтобы спросить у типа:
```python
A = [1000, 2000, 6, 8, 10, 12, 14,16,18, 999]
help(A.count())
```
```python
help('int')
```
```python
int('ZERO', 36) # 1652100
```
```python
p = 35*36**3 + 14*36**2 +(ord('R')-ord('A')+10)*36 + (ord('O')-ord('A')+10)
```
### Конкатенация
```python
A = [1, 2, 3, 4, 5]
B = [3, 2, 1]
print(A + B) # [1, 2, 3, 4, 5, 3, 2, 1]
print(B + A) # [3, 2, 1, 1, 2, 3, 4, 5]
str_1 = "asdf"
str_2 = "qwer"
print(str_1 + str_2) # ['asdfqwer']
```

### Умножение в list 
Если мы захотим умножить A * B, у нас ничего не выйдет
```python
A = [1, 2, 3, 4, 5]
print(A * 2) # [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
A = [0] * 100
print(A)  # Cписок из 100 нулей [0,0,0,0 ... ,0]
len[A] # 100
```

```python
A = [0] * 100
for i in range(len(A)):
    A[i] = i ** 2
print(A)
```

### Добавления в списки Python (.append)
```python
B = [3, 2, 1]
B.append(4)
print(B) # [3, 2, 1, 4]
B.append(5)
B.append(6)
print(B) # [3, 2, 1, 4, 5, 6]
```

### Вставка элемента в список Python
```python
B = [3, 2, 1]
B.insert(0, 100)
B.append(B) # [100, 3, 2, 1] <--- элемент сдвигает весь список на 1 
```

### Список в списке
Самое главное, что список в списке, не является двумерным массивом!
```python
A = [[1,2,3], [4,5,6], [7,8,9]]

for i in range(len(A)):
    for k in range(len(A[i])):
        print(( A[i])[k], end=' ')
    print()
```
Это эмуляция двумерного массива и вот почему:

```python
A = [1, 2, 3] * 3
print(A) # [[1,2,3] , [1,2,3], [1,2,3]] 
print(id (A[0]) == id(A[1])) # True
print(A[0] is A[1]) # True 
A[0][0] = 100 
print(A) # [[100,2,3],[100,2,3],[100,2,3]] <----- получается это лишь ссылки
```