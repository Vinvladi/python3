# Лекция 9-11 Все о строках
# ("hello",'hello',"hello') в IDLE Shell 'hello' и "hello" ----> результат на экране hello (исключение 'hello" - в данном случае вы не поставили закрывающийся апостров)
# (hello) Если там же написать просто hello (то будет ошибка traceback), python воспринимает это не как текст, а имя переменной, следовательно так как мы ее не создавали, будет выводится ошибка
# ('hello + enter) Если будет написано 'hello + клавиша enter, аналогично выпадет ошибка (SyntaxError)
# '''hello (результатом данных трех строчек записи будет 'hello\nworld\n456' , где \n - это перевод на новую строку (указываются после перехода на другую строку))
# world
# 456'''
# print('hello\nworld\n456') в данном случае будет написано: hello (вывод без кавычек)
#                                                            world
#                                                            456
# s1 = 'hello' (в данном случае мы сохранили строчку при помощи оператора присваивания)
# r = input()  (в данном случае пользователь сам вводит строку)
# Пример: world  r 'world' (r выведет в shell 'world')
#
# Еще пример
# d = ' ' - с использованием пробела
# e = ''
# 
# Операции со строками
# 1) Конкатенация (сцепление строк) (concatenate) (сложение строк)
# 1.1) 'abc' + 'dec'
# вывод 1.1 в Shell : 'abcdec'
# 1.2) s1+r
# вывод 1.2 в Shell : 'helloworld'
# 1.3) s1 +' '+r
# вывод 1.3 в Shell : 'hello world'
# 1.4) 'abc' + 3
# вывод 1.4 в Shell : Строки нельзя сцеплять с числом! (так как эти два разных типа не поддерживают операцию сложение)
# 1.4.1) 'abc' + str(3)  (операция str(3) сначала преобразует 3 в строку одного символа)
# вывод 1.4.1 в Shell : 'abc3'  (это правильный вариант для записи 1.4.1)
# 2) Повторение строки (или умножение (запись несколько раз))
# 2.1) 'a'* 5
# вывод 2.1 в Shell : 'aaaaa'
# 2.2) s1 * 3
# вывод 2.2 в Shell : 'hellohellohello'
# 2.3) s1 * 3.5
# вывод 2.3 в Shell : На вещественное число невозможно умножать!
# 3) Нахождение длины строки len (lenght - длина, сокращено len)
# 3.1.1) len ('abc')
# вывод 3.1.1 в Shell : 3 
# 3.1.2) len ('')  - пустая строка
# вывод 3.1.2 в Shell : 0 
# 3.1.3) len (' ')  - строка из одного пробела
# вывод 3.1.3 в Shell : 1
# 3.2) len (s1)  (Также в len можно задавать строку (s1 = 'hello'))
# вывод 3.2 в Shell : 5
# 3.3) Пример программы с input 
# s = input()  (все знаки подсчитываются, в том числе пробелы)
# print ("Вы ввели", len(s),'символов') 
# 4) Операция in (Есть ли какая подстрока в нашей строке)
# 4.1) s2 = '!@#$4567'
# Код операции in: '4' in s2
# вывод 4.1 в Shell : True
# 4.2.1) '45' in s2 (Также возможно проверять сколько угодно элементов)
# вывод 4.2.1 в Shell : True
# 4.2.2) '54' in s2  (Важен порядок в котором символы находятся)
# вывод 4.2.2 в Shell : False
# 5) Сравнение строк 
# 5.1) Операция == (равно)
# 1) 'aaa' = 'aaa' (строки равны когда целиком совпадают их символы и длины строк)
# вывод 5.1.1 в Shell : True
# 2) 'AAA' = 'aaa'
# вывод 5.1.2 в Shell : False
# 3) 'input' == 'input '
# вывод 5.1.3 в Shell : False
# 5.2) Операции сравнения
# 1) 'abc' > 'r'
# вывод 5.2.1 в Shell : False (Казалось бы должно быть наоборот, но python сравнивает элементы строки посимвольно, то есть в нашем случае взялись только первые символы строки)
# по алфавиту буква r будет позже a.
# 
# ФУНКЦИЯ ord (перевод в числовые значения по кодированию) (ascii code table)
# 6.1.1 ord('a') / ord('r') / ord('b') / ord('A')
# вывод :  97        114        98         65
# 
# 2) Исходя из 6.1.1 
# 'GJHJKSG' < 'afdgf'
# вывод 5.2.2 в Shell : True
# 3) 'abc' < 'abcd'
# вывод 5.2.3 в Shell : True
#
# 10 Урок. СТРОКИ: ИНДЕКСЫ И СРЕЗЫ
# Строка представляет собой упорядоченную коллекцию символов (Strings) , у каждого символа строки есть свой порядковый номер
# 0.1) 0 1 2 3 4 5 6 7 8 9 10 ... N (порядковый номер называется индексом)
#      hello world
# 0.2) -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 (другая нумерация символов)
# 1.1) s = 'hello world'
# s
# вывод 1.1 в Shell : 'hello world'
# 2) Индекс конкретной строки 
# Основная форма s[k], где s - конкретная строка, k - порядковый номер элемента | 'строка'[порядковый номер элемента строки]
# 2.1) s[6]
# 2.2) s[10]
# 2.3) 'abcd'[1]
# вывод 2.1/2.2/2.3 в Shell : 'w', 'd', 'b'
# 2.4) s[14]
# вывод 2.4 в Shell: IndexError (индекс строки вышел за границу строки)
# d = 'privet'
# 2.5 - 2.7) d[0] = 'p' , d[1] = 'r', d[5] = 't' #номер последнего индекса на 1 меньше, чем длина всей строки из этого следует последний индекс можно записать:
# 3) Нахождение последнего индекса строки
# 3.1) s[len(s)-1] - из длины вычитаем 1 элемент
# вывод 3.1 в Shell : 'd'
# 3.2) В python существует и другая нумерация индексов (0.2) ===>
# s[-1] 
# вывод 3.2 в Shell : 'd'
# 
# ПОДТЕМА: СРЕЗЫ
# 1) Обычные срезы с элемента по элемент
# 1.1) s[2:6] - при срезах левое значение берется, а правое нет матиматическая форма [2,3,4...6)
# вывод 1.1 в Shell : 'llo w'
# 1.2) s[6:9] 
# вывод 1.2 в Shell : 'wor'
# 1.3) s[4: ] - форма записи от 4 и до последнего элемента
# вывод 1.3 в Shell : 'o world'
# 1.4) s[:4] - опять же до 3-го элемента
# вывод 1.4 в Shell : 'hell'
# 1.5) s[:] - берет все элементы
# вывод 1.5 в Shell : 'hello world'
#
# 2) Выборочные срезы с шагом 
# 2.1 s[::2]
# вывод 2.1 в Shell : 'hlowrd'
# 2.2 s[1::2]
# вывод 2.2 в Shell : 'el ol'
# 2.3 s[::-1] (обратная запись данных)
# вывод 2.3 в Shell : 'dlrow olleh' 
# 
# 3) Объединенная форма с определенного элемента по определенный элемент, с шагом.
# 3.1) s[2:8:3] шаг 3 дает по итогу 2 / 5 элемент, но так как 8 не входит по [2,...,8)
# вывод 3.1 в Shell : 'l ' 
#
# Так как строки не изменяемые, если мы возьмем s[1] и попытаемся записать какой-либо другой символ s[1]='a', то мы получим ошибку строка не получит изменения, поэтому:
# для того чтобы в строке s изменить элемент s[4] на букву 'a' мы можем:
# 4.1.1) s[:4] + 'a' + s[5:]
# вывод 4.1.1 в Shell : 'hella world' 
# но при этом если мы возьмем и напишем s в shell то получим: 'hello world'
# и для того, чтобы присвоить значение s необходимо:
# 4.1.2) s = s[:4] + 'a' + s[5:]      (по сути мы берем первую часть строки затем с помощью конкатенации добавляем второй элемент и берем вторую часть)
# вывод 4.1.2 в Shell : 'hella world' 
#
# УРОК 11. СТРОКИ И ИХ МЕТОДЫ В PYTHON
# Метод - это просто функция, связанная с определенным типом объекта. То есть методы являются специфичными для каждого отдельного типа.
# Вызов метода: объект.метод(аргументы)
# 1. Метод upper. превращает все элементы строки в заглавные
# 1.1) 'hello'.upper()
# вывод 1.1 в Shell : 'HELLO'
# 1.2) 'hello123$'.upper()
# вывод 1.2 в Shell : 'HELLO123$' - как мы видим меняются только буквы на заглавные
# 1.2.a) А что произойдет, если мы забудем поставить (), то 
# 1.2.a) python покажет, что есть такой метод, но ничего не выдаст толкового
# 2. Метод . Противоположный метод. 'str'.lower()
# 2.1) 'HELLO123$'.lower()
#  'Hello123$'
# 
# Важное уточнение, что данные методы не влияют на само строку:
# s ='hello world'
# s.upper()
# вывод в Shell : 'HELLO WORLD'
# если мы проврим s , в выводе Shell:'hello world' (ничего не изменилось)
# для изменения s=s.upper() или s=s.lower()
#
# 3. Метод count (количество, метод записи n.count(), где n - это заданная строка)
# 3.1) s.count('o') - это подсчет элементов в конкретной строке s
# s.count('o') 
# вывод 3.1 в Shell: 2 (так как 2 раза встречается o)
# если мы не передаем вообще в () ничего, то у нас будет снова выдавать ошибку. Необходимо назначить, хотя бы один аргумент
# 3.2) при вводе s.count( - выходит подсказка, сколько элементов необходимо передать : s.count(sub[, start[, end]]) -> int
# sub - обозначает подстроку (sub - является обязательным) в тетрадке более наглядно стр 20 начало 
# 3.2.1) s.count('o',6) - сколько нам встретилась o начиная с 6-ой позиции 
# вывод 3.2.1 в Shell: 1 (так как в строке позиция начинается с 0)
# 3.2.2) s.count('o',8) (так как элемент находится на 8 позиции, но индекс у элемента 7)
# вывод 3.2.2 в Shell: 0 
# 3.3) Задаем 3 параметра:
# 3.3.a) s.count ('l',1,3) - данный диапазон элементов с 1 по 3 не включительно по индексам
# вывод 3.3.a в Shell: 1 
# 3.3.b) s.count ('l',1,4) - данный диапазон элеменов с 1 по 4 (1,2,3) (4 - не входит)
# вывод 3.3.b в Shell: 2 
# 
# 4.FIND + RFIND (метод ищет номер подстроки, который вы хотите найти) (find - поиск справа / rfind - поиск слева)
# 4.1) s.find('e')
# вывод 4.1 в Shell: 1
# 4.2) s.find('wor')
# вывод 4.2 в Shell: 6 - он вернет позицию, где начнется полное совподение 
# 4.3) s.find('z')
# вывод 4.3 в Shell: -1 в этом случае, он вернет нам значение -1, так как нет элементов z в данной строке s 
# 4.4.1.a) s.find('o') - слева
# вывод 4.4.1.a) в Shell: 4 - будет возвращено только первое упоминание данного элемента (букву, которую он найдет слево)
# 4.4.1.b) s.find('o',6) - поиск с 6-го элемента
# вывод 4.4.1.b) в Shell: 7
# 4.4.2) s.rfind('o') - справа первый элемент
# вывод 4.4.2 в Shell: 7
# 
# 5. INDEX. Метод index, возвращает индекс вашей подстроки
# 5.1) s.index('o')
# вывод 5.1 в Shell: 4
# Примечание: Разница между методом индекс и find в том, что если:
# s.index('z') - в этом случае консоль выдаст ValueError, а find возвращает -1, то есть не завершается аварийно
#
# 6. Replace (замена)
# у данного метода 2 обязательных условия s.replace(old,new, count=-1, /), old и new (old - что мы будем менять, второй на что мы будем менять)
# 6.1) s.replace('o','???')
# вывод 6.1 в Shell: 'hell??? w???rld', каждая буква o была заменина 
# s строка также свои значения не меняла, а для переназначения строки надо использовать форму s = s.replace('o','???')
# 6.2) также с помощью replace мы можем убрать элемент встречающийся несколько раз и можем изменить просто на пустую строку:
# s.replace('l','') - все l будут убраны из строки
# вывод 6.2 в Shell: 'heo word'
#
# 7. Методы проверяющие из каких символов состоит строка. Метод isalpha - число состоит только из букв | isdigit - состоит ли строка из элементов
# 7.1) k = 'sdsewQ'
# k.isalpha() 
# вывод 7.1 в Shell: True
# 7.2.a) '1324'.isdigit()
# вывод 7.2.a в Shell: True
# 7.2.b) '13 24'.isdigit()
# вывод 7.2.b в Shell: False - данные проерки очень полезны для преобразования в число int
# int('4 32') - выдаст ошибку
# 
# 8. Методы rjust и ljust. Эти методы дополняют строку до указанной длины
# d ='111' 
# 8.1.a) Строка прижимается к правому краю
# d.rjust (5), shell 8.1.a: '  111' 
# 8.1.b) d.rjust (5,'0'), shell 8.1.b: '00111'
# 8.2.a) Строка прижимется к левому краю
# d.ljust (5), shell 8.2.a: '111  '
# 8.2.b) d.ljust (5,'0'), shell 8.2.b: '11100'
# 8.1 и 8.2 в данных методах невозможно передавать несколько символов:
# 8.1.w / 8.2.w : d.rjust(5,'--') и d.ljust(5,'--') - так как этот конкретный метод ждет от нас только 1-го значения
#
# 9. Метод SPLIT. split() - разбивает строку на ['1','2',...], там где стоит пробел (в тетрадке подробнее стр 20)
# w='ivanov ivan ivanovich'
# 9.1) w.split()
# вывод 9.1 в Shell: ['ivanov','ivan','ivanovich']
# 9.2) Split + len
# len(w.split()) 
# вывод 9.2 в Shell: 3 - будут посчитано количество слов 
# 9.3) w.split('n') - если бьем по букве n
# вывод 9.3 в Shell: ['iva', 'ov iva', 'iva', 'ovich'] - 4 элемента, так как 3 n встречается
# 
# Строку в список и наоборот 9.4 split 9.5 метод join - объединить
# 9.4) t = '43,543,765,3,765,432'split(',')
# Shell 9.4 t: ['43', '543', '765', '3', '765', '432']
# чтобы наоборот перейти из списка к строке, например выберем '='
# 9.5) '='.join(t)
# вывод 9.5 в Shell: '43=543=765=3=765=432' (перед первым и последним элементом не будет =)
#
# Join + split 
# 9.4/5) ','.join(w.split()), где w='ivanov ivan ivanovich'
# вывод 9.4/5 в Shell:'ivanov,ivan,ivanovich' 
#
# q='   hello  \n'  (\n - перенос на новую строчку)
# q в Shell: '   hello  \n'
# print(q) в Shell:   hello
#                          (на второй строчке нет ничего, но он перешел на нее)
# 10) Метод strip / rstrip / lstrip  - данный метод удаляет знаки пробелов пробелов и переносы на новые строки, как слева, так и справа / остальые работают немного по другому принципу описанному ниже в 10.2 и 10.3
# 10.1) q.strip() в shell: 'hello' 
# 10.2) q.rstrip() в shell: '   hello'
# 10.3) q.lstrip() в shell: 'hello  \n'
#
# 11) Пример:
# s = input()
# s в shell: 'hello'
# в shell s=input().upper() (мы введем слова privet), тогда при введении s в Shell: 'PRIVET'
#
# Мы можем вызывать методы цепочкой 
# 12.1) s.lower().replace('e','w') в Shell 12.1: 'privwt'
# s.lower().replace('e','w').upper() в Shell 12.2: 'PRIVWT'
